\documentclass[12pt]{article}
\usepackage[]{todonotes}

\newcommand{\code}{\texttt}

\title{The Coalton Standard Library}

\begin{document}

\maketitle
\section{Introduction}
The Coalton standard library is a set of foundational packages that
support practical application development, and are maintained alongside
the core language, sharing a common release and versioning
schedule. This report provides recommendations for the scope,
organization and content of these packages.

\section{General Recommendations}

\subsection{Compact Core}

The core language and compiler should be as small as is reasonable.
When possible, types should be defined in the standard library, rather
than as part of the core language. The core language should have
little need for knowledge about the structure and contents of its
libraries.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Relocate the definition of \code{char} to
  \code{coalton/data/char}, etc.
\end{itemize}

\subsection{Standard and Contributed Libraries}

Outside of the core language implementation, libraries can be
classified as either ``standard'' or ``contributed''.  The standard
library should contain definitions that are frequently used by most
applications written in Coalton, whereas contributed libraries should
contain definitions that support specific application domains, for
instance computer algebra, special kinds of network protocols, or io.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Move parts of \code{coalton-library/math/*} that are not
  relevant to common arithmetic and trigonometric operations with
  primitive types into a contributed library.
\item Move big float and associated tests to secondary library (and
  attempt to mitigate MPFR library presence related build errors).
\item Build and test contributed libraries in a separate phasea
  subsequent to building the core language and standard library.
\end{itemize}

\subsection{Documentation}

Full documentation is very important for both beginning and advanced
users.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Systematically vet the documentation string of every definition.
\item For each definition, provide a trivial but illustrative example
  with a known output.
\item Provide direct links from generated documentation to
  corresponding, versioned definitions in GitHub.
\item The documentation needs to be generated in some logical order,
  either file, or alphabetical.
\item Type variables are renamed in documentation: see, for instance 
\todo{q}
Free monad - why are the type variables renamed in the documentation?


\end{itemize}

\subsection{Self Sufficiency}

The language should be self sufficient, to the extent that the
standard library is able to self-update, and load contributed
libraries.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Plan to include network protocol and encryption support
  necessary to implement a secure package manager.
\end{itemize}

\subsection{Approachability}

Judge the contents of the standard library in light of commonly used
languages: how different are the core types, data and control
structures? How hard is it to read and write data? How hard is it to
write a CSV parser? Things that sound easy ought to be easy, and this
should be demonstrable.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Provide a rosetta stone comparing Coalton to js, python, etc.
\item Avoid ambiguity resulting from short nicknames, for instance,
  'ORD' for 'ORDER'
\item Avoid terse portmanteau prefixes such as ``mk''.
\item Provide extended data syntax for vectors, maps and sets.
\item Provide regular expression support in the standard library,
  i.e., wrap CL-PPCRE.

\end{itemize}

\subsection{Concrete Data Types and IO}

Provide general purpose concrete data types, and define read syntax for them.

\begin{itemize}
\item map: immutable map of keys to values (like dict, table, etc.)
\item vector: mutable array with get, set, push, pop
\item set: immutable set
\end{itemize}

\bigskip
\underline{Recommendations}
\begin{itemize}
\item Define map, vector and set
\item Consider adopting ``edn'' read syntax for these.
\end{itemize}

\section{Naming}

\subsection{Symbols}

\bigskip
\underline{Recommendations}
\begin{itemize}
\item Apply consistent naming to symbols: Python case for classes and
  instances, lisp-style hyphenation for functions.
\end{itemize}

\subsection{Packages}

The existing packages can have shorter names and better logical grouping.

\bigskip
\underline{Recommendations}
\begin{itemize}
\item Replace \code{coalton-library} with \code{coalton}.
\item Define a shallow package hierachy of maximum depth 3, with
  general features at the root, and specific features at the second
  level.
\item Put primitive types under \code{coalton/type}.
\item Put concrete data types under \code{coalton/data}.
\item Put typeclass definitions under \code{coalton/class}.
\item Put system and host resource access under \code{coalton/sys}.
\end{itemize}

\subsubsection{Proposed Layout}

\begin{itemize}
\item coalton
\item coalton/class
\item coalton/class/iterator, monad
\item coalton/class/monad
\item coalton/data
\item coalton/data/array, hash, list, map, queue, seq, tree, tuple, vector
\item coalton/function
\item coalton/math
\item coalton/mutable
\item coalton/sys
\item coalton/sys/{file
\item coalton/type
\item coalton/type/bit, byte, char, string
\end {itemize}

The toplevel packages ('data', 'type') are good places to relocate
type classes that may apply to more than one concrete type.

\subsection{Types}

\subsubsection{Primitive Types}

which types are core types? It may be the best that no types are
primitive types. What Coalton is really providing is abstraction.
\todo{primitive}

\todo{q}
is there a way to eject builtin types from the typecheckers?

\todo{q}
How much does the typechecker need ot know about primitive types at compile time?

\subsection{Tuples}

The ought be no need to characterize tuples as Tuple2, Tuple3,
Tupld4. At very least the numerically-suffixed structure classes that
provide tuple storage ought to be obscured by notation.

Tuples receive ordinal accessors (first, second, third).

It may be desirable to support named tuples, to provide better cues
about function.

\todo{q}
Is there a conflict or overlap with coalton-library/struct?

tuples as an existential type.
\todo{what did we mean?}

\subsection{Casting}

There are a lot of disparate casting functions that ought to be
replaced by into -- notable, as below, tointeger.

\subsection{Package Audit}

\subsubsection{coalton}

This package exposes built-in types (Unit, UFix, Single-Float) and
toplevel and syntactic forms (define-instance, let).

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Documentation for all symbols should appear here: notably absent
  are define-struct, define-class, define-instance.
\end{itemize}

\subsubsection{coalton-library/bits}

Support for bitwise operations. The implementations are present in \code{coalton-library/math/num}.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Rename to \code{coalton/type/bit} to represent that these operations are generally against concrete machine values defined there.
\end{itemize}

\subsubsection{coalton-library/builtin}

This package contains an assortment of definitions related to functions and boolean logic.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Remove this package
\item Move \code{undefined} to functions
\item Move all other functions to \code{coalton/type/boolean}
\end{itemize}

\subsubsection{coalton-library/char}

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Define \code{char} at the top of this file, not as an early type.
\end{itemize}

\subsubsection{coalton-library/cell}

\todo{q}
How closely related are cell and random-access?

\todo{q}
It seems like 'cell' should be a pure mutation interface,
that doesn't have any assumptions about the kind of type to which a
reference is being maintained.

\todo{q}
Are vectors able to supersede a bunch of other stuff (cell, list)

\subsubsection{coalton-library/classes}

This package contains a mixture of comparison (Eq, Ord), control flow
(Optional, Result, Signalable, Unwrappable), and storage (Tuple)
classes.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Relocate tuple definition to \code{coalton/data/tuple}
\item Relocate control flow and error classes to ``coalton/error''
\item Improve tuple documentation ('heterogeneous collection of items')
\end{itemize}

\todo{note}
There should be some way to easily define a bit or byte type -
for U7, or whatever particular value. See also notes in ... math bits?
... about taking machine types (U8, I8) and 1 taking their definitions
out of core 2) into a single package in std lib.

\todo{note}
rationalization of max and min

\subsubsection{coalton-library/functions}

\todo{q}
\code{/=} goes to classes

\todo{q}
can flip be gotten rid of?

\todo{q}
trace and trace object need ot be move to format library.

\todo{rec}
The proxy system (or its interface) should be reassessed. Consider
the example of setting the element type when reading a vector.

\todo{q}
Boolean: when would you use Ord over Boolean?

ascii - really means utf8 or whatever the platform uses

the char package needs to have all of its assumptions checked

\subsubsection{coalton-library/math/fraction}

R: mkfraction - the 'mk' prefix is unique here: is there a naming convention to apply?

Q: Fraction is a primitive type, just a wrapper for a lisp fraction, and appears in primitive-types.

N: implementation of primitive types is kind of a mess, for instance
the defvar in typechecker/types.

the type definition should probably be in this file

clearly mark that this is a CL rational

\subsubsection{coalton-library/hash}

\todo{q}
do other languages "expose an interface to hashing."

\todo{note}
add example: hashable label type with string-typed label.

HASH should be a nonexternal library: just provides one method to hash table.

HASH should be in hashtable file.

There should be documentation here that provides a rationale for a hash user.

\subsubsection{coalton-library/tuple}

write a whole para on traverse. the methods all need descriptions

talk about traversable and sequence

\subsubsection{coalton-library/math/integral}

\todo{q}
tointeger seems to overlap completely with (into Integer ..)
- can it be collapsed? What is the purpose, otherwise?

\todo{q}
"to-" prefix: is it like "mk-" prefix?

N: it may be confusing to have multiple (semantically identical)
definitions

\todo{q}
Are there problems with integral-\gt{}num? Can it be killed? It seems
ot only add syntax, in that it could be equally well expressed as
(into X whatever) rather than (the foo (integral->num whatever)).

\todo{q}
How sound is semigroup? What is it used for, what does it support?

\todo{q}
are there different 'flavors' of Boolean that should be picked apart?

R: "/=" should be in classes, not in fucntions

\todo{q}
we need a thin wrapper on lisp format.

\todo{q}
format error function

Recommendation: Move dyadic and dual to secondary packages.

\todo{note}
bifunctor shouldn't in core, someone can define it as part of
      something they need

There needs to be some docstring for SEQUENCE [FUNCTION] - switches between types of containers

Unwrappable should be its own thing, and the gateway to the condition
system, since it's a way to handle errors.

Optional and result should also go into that file.

The repr for enum types should be exposed in the documentation.

\subsubsection{coalton-library/math/arith}

Split N string - > tuple string

\todo{note}
unchecked -> unsafe

\todo{note}
car/cdr,  first/rest

\subsubsection{coalton-library/list}

This is a big package.

\todo{note}
The semantics of remove-if are weird: only operates on first match?

\todo{q}
equivalence-classes?

\todo{todo}
Audit for "XXX"! with return value + side effects or mutation

"implemented by a linked list - what?

\todo{note}
up-to and down-from are weird.

\todo{q}
elementwise-hash! is specialized to the implementation of ord-trees, and belongs there

\todo{q}
remove-duplicates! shows up in a weird place and duplicates a documentation section

\todo{note}
ord-tree collect! tree - should be into iterator?

\todo{q}
".like replace-or-insert" - do those really have to have names that are so similar?

\todo{q}
ord-map: why is there not ord in entries?

\todo{rec}
The SEQ types seems hollowed out or superseded by vector and iterator stuff: does it stay or go?

\todo{rec}
Replace -unsafe with -safe

bounded (minvalue maxvalue) is kind of like hash in that i'ts ring-0 or lower order

\end{document}
