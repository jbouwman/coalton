\documentclass[12pt]{article}
\usepackage[]{todonotes}

\newcommand{\code}{\texttt}

\title{The Coalton Standard Library}

\begin{document}

\maketitle
\section{Introduction}
The Coalton standard library is a set of foundational packages that
support practical application development, and are maintained alongside
the core language, sharing a common release and versioning
schedule. This report provides recommendations for the scope,
organization and content of these packages.

\section{General Recommendations}

\subsection{Core}

The core language and compiler should be as small as is reasonable.
When possible, types should be defined in the standard library, rather
than as part of the core language. The core language should have
little need for knowledge about the structure and contents of its
libraries.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Relocate \code{char} to \code{coalton/data/char}, etc.
\end{itemize}

\subsection{Standard and Contributed Libraries}

Outside of the core language implementation, libraries can be
classified as either ``standard'' or ``contributed''.  The standard
library should contain definitions that are frequently used by most
applications written in Coalton, and contributed libraries should
contain definitions that support specific application domains, for
instance computer algebra, or special kinds of network protocols and
data formats..

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Move parts of \code{coalton-library/math/*} that are not
  relevant to common arithmetic and trigonometric operations with
  primitive types into a contributed library.
\item Move \code{big float} and associated tests to secondary library,
  and attempt to mitigate MPFR-related build errors.
\item Build and test contributed libraries in a separate phase
  subsequent to building the core language and standard library.
\end{itemize}

\subsection{Documentation}

Full documentation is important for both beginer and advanced users;
lack of it is an impediment to uptake of the language, and can lead
users to spend time duplicating existing features. There are excellent
models to follow, provided by similar functional languages that also
intend to support general use.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Systematically vet the documentation string of all definitions.
\item For each definition, provide a trivial but illustrative example
  with a known output.
\item Provide links from generated documentation to corresponding,
  versioned definitions in GitHub.
\item Generate documentation in some logical order: either by
  occurrence in file, or alphabetically.
\item Type variables are misleadingly renamed in documentation: for
  instance, \code{(define-type (Free :f :a)} is documented as
  \code{FREE :A :B} with the documentation \code{`Free :f` gives
    you...}
\item Preserve case of types and functions in documentation, instead
  of folding everything to uppercase.
\end{itemize}

\subsection{Self Sufficiency}

The language should be self sufficient, to the extent that the
standard library is able to self-update, and load contributed
libraries.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Plan to include network protocol and encryption support
  necessary to implement a secure package manager.
\end{itemize}

\subsection{Usability}

Judge the contents of the standard library in light of commonly used
languages: how different are the core types, data and control
structures? How hard is it to read and write data? How hard is it to
write a CSV parser? Things that sound easy ought to be easy, and this
should be demonstrable.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Provide a rosetta stone comparing Coalton to js, python, etc.
\item Avoid ambiguity resulting from short nicknames, for instance,
  'ORD' for 'ORDER'
\item Avoid terse portmanteau prefixes such as ``mk''.
\item Provide regular expression support in the standard library,
  i.e., wrap CL-PPCRE.

\end{itemize}

\subsection{Concrete Data Types and IO}

Provide general purpose concrete data types, and define read syntax
for them. This allows users to get data into and out of Coalton
programs without derailing.

\begin{itemize}
\item map: immutable map of keys to values (like dict, table, etc.)
\item vector: mutable array with get, set, push, pop
\item set: immutable set
\end{itemize}

\bigskip
\underline{Recommendations}
\begin{itemize}
\item Define map, vector and set
\item Provide edn and yaml IO for these.
\end{itemize}

\section{Naming}

\subsection{Symbols}

Symbols are inconsistently named and cased.

\bigskip
\underline{Recommendations}
\begin{itemize}
\item Apply consistent naming to symbols: Python case for classes and
  instances, lisp hyphenation for functions.
\end{itemize}

\subsection{Packages}

The existing packages can have shorter names and better logical grouping.

\bigskip
\underline{Recommendations}
\begin{itemize}
\item Replace \code{coalton-library} with \code{coalton}.
\item Define a shallow package hierachy of maximum depth 3, with
  general features at the root, and specific features at the second
  level.
\item Place primitive types under \code{coalton/type}.
\item Place concrete data types under \code{coalton/data}.
\item Place typeclass definitions under \code{coalton/class}.
\item Place system and host resource access under \code{coalton/sys}.
\end{itemize}

\subsubsection{Proposed Layout}

\begin{itemize}
\item coalton
\item coalton/class
\item coalton/class/iterator, monad
\item coalton/class/monad
\item coalton/data
\item coalton/data/array, hash, list, map, queue, seq, tree, tuple, vector
\item coalton/function
\item coalton/math
\item coalton/mutable
\item coalton/sys
\item coalton/sys/{file
\item coalton/type
\item coalton/type/bit, byte, char, string
\end {itemize}

The toplevel packages ('data', 'type') are good places to relocate
type classes that may apply to more than one concrete type.

\subsection{Types}

\subsubsection{Primitive Types}

The set of types defined in compielr source code is Boolean, Unit,
Char, Integer, Single-Float, Double-Float, String, Fraction, Arrow,
List. 

\bigskip
\underline{Recommendations}
\begin{itemize}
\item Relocate type definitions from compiler to standard library.
\item Reduce core types to: Unit, Bool, Char, String, Integer, Float.
\end{itemize}

\subsection{Tuples}

The existence at a public API level of names like Tuple2, Tuple3,
... TupleN is surprising and unusual.

\bigskip
\underline{Recommendations}
\begin{itemize}
\item Provide syntax for direct representation of tuples.
\item Provide syntax for destructuring of tuples.
\item Conside renaming ``fst'' to ``first'' and ``snd'' to ``second''.
\end{itemize}

\subsection{Casting}

There are a disparate casting functions that might be
replacable by \code{into} notably, tointeger.

\subsection{Package Audit}

\subsubsection{coalton}

This package exposes built-in types (Unit, UFix, Single-Float) and
toplevel and syntactic forms (define-instance, let).

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Documentation for all symbols should appear here: notably absent
  are define-struct, define-class, define-instance.
\end{itemize}

\subsubsection{coalton-library/bits}

Support for bitwise operations. (Implementations are in
\code{coalton-library/math/num}).

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Rename to \code{coalton/type/bit} to represent that these
  operations are generally against concrete machine values defined
  there.
\end{itemize}

\subsubsection{coalton-library/builtin}

This package contains definitions related to functions and boolean
logic.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Remove this package
\item Move \code{undefined} to functions
\item Move all other functions to \code{coalton/type/boolean}
\end{itemize}

\subsubsection{coalton-library/char}

This package contains character attribute predicates, and a generator
for character ranges.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Define \code{char} at the top of this file, not as an early type.
\item Check code assumptions, and remove 'ascii' from names and documentation.
\end{itemize}

\subsubsection{coalton-library/cell}

Defines operations on a single mutable value. There are additional
functions that assumpe specific types of stored values: integers,
lists.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Define only the core operations: get, set, and swap.
\end{itemize}

\subsubsection{coalton-library/classes}

This package contains comparison (Eq, Ord), control flow (Optional,
Result, Signalable, Unwrappable), and storage (Tuple) classes.

\bigskip
\underline{Recommendations}

\begin{itemize}
\item Relocate tuple definition to \code{coalton/data/tuple}
\item Relocate control flow and error classes to ``coalton/error''
\item Improve tuple documentation ('heterogeneous collection of items')
\end{itemize}



\todo{note}
There should be some way to easily define a bit or byte type -
for U7, or whatever particular value. See also notes in ... math bits?
... about taking machine types (U8, I8) and 1 taking their definitions
out of core 2) into a single package in std lib.

\todo{note}
rationalization of max and min

\subsubsection{coalton-library/functions}

\todo{q}
\code{/=} goes to classes

\todo{q}
can flip be gotten rid of?

\todo{q}
trace and trace object need to be moved to a format library.

\todo{rec}
The proxy system (or its interface) should be reassessed. Consider
the example of setting the element type when reading a vector.

\todo{q}
Boolean: when would you use Ord over Boolean?

\subsubsection{coalton-library/math/fraction}

R: mkfraction - the 'mk' prefix is unique here: is there a naming convention to apply?

Q: Fraction is a primitive type, just a wrapper for a lisp fraction, and appears in primitive-types.

N: implementation of primitive types is kind of a mess, for instance
the defvar in typechecker/types.

the type definition should probably be in this file

clearly mark that this is a CL rational

\subsubsection{coalton-library/math/integral}

\todo{q}
tointeger seems to overlap completely with (into Integer ..)
- can it be collapsed? What is the purpose, otherwise?

\todo{q}
"to-" prefix: is it like "mk-" prefix?

N: it may be confusing to have multiple (semantically identical)
definitions

\todo{q}
Are there problems with integral-\gt{}num? Can it be killed? It seems
ot only add syntax, in that it could be equally well expressed as
(into X whatever) rather than (the foo (integral->num whatever)).

\todo{q}
How sound is semigroup? What is it used for, what does it support?

\subsubsection{coalton-library/hash}

\todo{q}
do other languages "expose an interface to hashing."

\todo{note}
add example: hashable label type with string-typed label.

HASH should be a nonexternal library: just provides one method to hash table.

HASH should be in hashtable file.

There should be documentation here that provides a rationale for a hash user.

\subsubsection{coalton-library/tuple}

write a whole para on traverse. the methods all need descriptions

talk about traversable and sequence


\todo{q}
are there different 'flavors' of Boolean that should be picked apart?

R: "/=" should be in classes, not in functions

\todo{q}
we need a thin wrapper on lisp format.

\todo{q}
format error function

Recommendation: Move dyadic and dual to secondary packages.

\todo{note}
bifunctor shouldn't in core, someone can define it as part of
      something they need

There needs to be some docstring for SEQUENCE [FUNCTION] - switches between types of containers

Unwrappable should be its own thing, and the gateway to the condition
system, since it's a way to handle errors.

Optional and result should also go into that file.

The repr for enum types should be exposed in the documentation.

\subsubsection{coalton-library/math/arith}

Split N string - > tuple string

\todo{note}
unchecked -> unsafe

\todo{note}
car/cdr,  first/rest

\subsubsection{coalton-library/list}

This is a big package.

\todo{note}
The semantics of remove-if are weird: only operates on first match?

\todo{q}
equivalence-classes?

\todo{todo}
Audit for "XXX"! with return value + side effects or mutation

"implemented by a linked list - what?

\todo{note}
up-to and down-from are weird.

\todo{q}
elementwise-hash! is specialized to the implementation of ord-trees, and belongs there

\todo{q}
remove-duplicates! shows up in a weird place and duplicates a documentation section

\todo{note}
ord-tree collect! tree - should be into iterator?

\todo{q}
".like replace-or-insert" - do those really have to have names that are so similar?

\todo{q}
ord-map: why is there not ord in entries?

\todo{rec}
The SEQ types seems hollowed out or superseded by vector and iterator stuff: does it stay or go?

\todo{rec}
Replace -unsafe with -safe

bounded (minvalue maxvalue) is kind of like hash in that i'ts ring-0 or lower order

\end{document}
